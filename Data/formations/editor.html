<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Formation Editor</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: 'Segoe UI', Tahoma, sans-serif; background: #1a1a2e; color: #e0e0e0; padding: 20px; }
h1 { color: #e94560; margin-bottom: 10px; font-size: 1.4em; }

.header { display: flex; align-items: center; gap: 16px; margin-bottom: 16px; flex-wrap: wrap; }
.header label { font-weight: 600; }
#fileInput { background: #16213e; color: #e0e0e0; border: 1px solid #0f3460; padding: 6px 10px; border-radius: 4px; }
#areaInfo { background: #16213e; padding: 12px 16px; border-radius: 6px; margin-bottom: 16px; border-left: 4px solid #e94560; }
#areaInfo .title { font-size: 1.2em; font-weight: 700; color: #e94560; }
#areaInfo .subtitle { color: #a0a0b0; margin-top: 4px; }

.palette { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
.palette-chip { padding: 4px 10px; border-radius: 12px; font-size: 0.85em; font-weight: 600; color: #000; }

.budget-bar { background: #16213e; border-radius: 6px; padding: 12px 16px; margin-bottom: 16px; }
.budget-label { font-weight: 600; margin-bottom: 6px; }
.budget-track { background: #0a0a1a; border-radius: 4px; height: 22px; position: relative; overflow: hidden; }
.budget-fill { height: 100%; border-radius: 4px; transition: width 0.3s; }
.budget-fill.ok { background: linear-gradient(90deg, #0f3460, #53a8b6); }
.budget-fill.warn { background: linear-gradient(90deg, #e94560, #ff6b6b); }
.budget-text { position: absolute; top: 0; left: 0; right: 0; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 0.8em; font-weight: 600; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.5); }

.toolbar { display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap; }
button { background: #0f3460; color: #e0e0e0; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 0.9em; }
button:hover { background: #1a508b; }
button.danger { background: #a01030; }
button.danger:hover { background: #c01040; }
button.primary { background: #e94560; color: #fff; }
button.primary:hover { background: #ff6b80; }
button:disabled { opacity: 0.4; cursor: default; }

.section-title { color: #e94560; font-size: 1.1em; font-weight: 700; margin: 20px 0 10px; padding-bottom: 4px; border-bottom: 1px solid #2a2a4e; }

.formations { display: flex; flex-direction: column; gap: 12px; }
.formation-card { background: #16213e; border-radius: 8px; padding: 14px; border: 2px solid transparent; transition: border-color 0.2s; }
.formation-card.selected { border-color: #e94560; }
.formation-card-header { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
.formation-card-header .f-label { font-weight: 700; font-size: 0.95em; color: #53a8b6; min-width: 28px; }
.formation-card-header .f-total { color: #808090; font-size: 0.85em; }
.formation-card-header .f-suffix { color: #505060; font-size: 0.75em; font-family: monospace; margin-left: auto; }
.formation-card-header input[type="checkbox"] { accent-color: #e94560; width: 16px; height: 16px; cursor: pointer; }

.pills { display: flex; gap: 4px; flex-wrap: wrap; margin-bottom: 10px; }
.pill { padding: 3px 8px; border-radius: 10px; font-size: 0.8em; font-weight: 600; color: #000; }

.slot-controls { display: flex; gap: 6px; flex-wrap: wrap; align-items: center; }
.slot-control { display: flex; align-items: center; gap: 4px; background: #0a0a1a; border-radius: 6px; padding: 4px 8px; }
.slot-control .name { font-size: 0.85em; font-weight: 600; min-width: 80px; }
.slot-control button { padding: 2px 8px; font-size: 0.85em; min-width: 24px; }
.slot-control .count { font-size: 0.9em; font-weight: 700; min-width: 18px; text-align: center; }

.card-actions { display: flex; gap: 6px; margin-top: 10px; }

/* Spawn group cards */
.spawn-card { background: #16213e; border-radius: 8px; padding: 14px; margin-bottom: 8px; }
.spawn-card-header { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
.spawn-card-header .g-label { font-weight: 700; font-size: 0.9em; color: #53a8b6; }
.spawn-card-header .g-info { color: #808090; font-size: 0.8em; }
.spawn-card-header .g-suffix { color: #505060; font-size: 0.75em; font-family: monospace; margin-left: auto; }

.spawn-records { display: flex; flex-direction: column; gap: 4px; }
.spawn-record { display: flex; align-items: center; gap: 8px; background: #0a0a1a; border-radius: 4px; padding: 4px 8px; font-size: 0.82em; }
.spawn-record .rec-pill { padding: 2px 8px; border-radius: 8px; font-weight: 600; color: #000; cursor: pointer; user-select: none; min-width: 90px; text-align: center; transition: transform 0.1s; }
.spawn-record .rec-pill:hover { transform: scale(1.05); }
.spawn-record .rec-coords { color: #707080; font-family: monospace; font-size: 0.9em; }
.spawn-record .rec-meta { color: #505060; font-family: monospace; font-size: 0.85em; }

#status { margin-top: 12px; padding: 8px 12px; border-radius: 4px; display: none; font-weight: 600; }
#status.ok { display: block; background: #0f3460; color: #53a8b6; }
#status.err { display: block; background: #500020; color: #ff6b6b; }

.empty { color: #606070; font-style: italic; padding: 20px; text-align: center; }

/* Monster overrides */
.overrides-section { margin-bottom: 16px; }
.overrides-toggle { cursor: pointer; user-select: none; }
.overrides-toggle:hover { color: #e94560; }
.override-card { background: #16213e; border-radius: 8px; padding: 10px 14px; margin-bottom: 6px; }
.override-card.active { border-left: 3px solid #e94560; }
.override-header { display: flex; align-items: center; gap: 10px; }
.override-header .slot-chip { padding: 3px 10px; border-radius: 10px; font-size: 0.85em; font-weight: 600; color: #000; }
.override-header .slot-name { font-weight: 600; font-size: 0.9em; }
.override-header .ov-toggle { margin-left: auto; cursor: pointer; font-size: 0.85em; color: #53a8b6; }
.override-header .ov-toggle:hover { color: #e94560; }
.override-body { margin-top: 8px; display: flex; flex-direction: column; gap: 6px; }
.override-row { display: flex; align-items: center; gap: 8px; font-size: 0.85em; }
.override-row label { min-width: 90px; color: #a0a0b0; font-weight: 600; }
.override-row input, .override-row select { background: #0a0a1a; color: #e0e0e0; border: 1px solid #2a2a4e; padding: 4px 8px; border-radius: 4px; font-size: 0.9em; }
.override-row input { width: 160px; }
.override-row select { min-width: 160px; }
</style>
</head>
<body>

<h1>Formation Editor</h1>

<div class="header" id="headerLocal">
  <label>Load area JSON:</label>
  <input type="file" id="fileInput" accept=".json">
</div>
<div class="header" id="headerServer" style="display:none">
  <label>Level:</label>
  <select id="levelSelect" style="background:#16213e;color:#e0e0e0;border:1px solid #0f3460;padding:6px 10px;border-radius:4px;min-width:200px;font-size:0.95em;">
    <option value="">-- select level --</option>
  </select>
  <label>Area:</label>
  <select id="areaSelect" style="background:#16213e;color:#e0e0e0;border:1px solid #0f3460;padding:6px 10px;border-radius:4px;min-width:200px;font-size:0.95em;" disabled>
    <option value="">-- select area --</option>
  </select>
  <span id="serverBadge" style="background:#0f3460;color:#53a8b6;padding:3px 10px;border-radius:10px;font-size:0.8em;font-weight:600;">SERVER MODE</span>
</div>

<div id="areaInfo" style="display:none">
  <div class="title" id="areaTitle"></div>
  <div class="subtitle" id="areaSubtitle"></div>
  <div class="palette" id="palette"></div>
</div>

<div id="overridesSection" class="overrides-section" style="display:none">
  <div class="section-title overrides-toggle" id="overridesToggle">Monster Overrides <span id="overridesArrow">&#9654;</span></div>
  <div id="overridesBody" style="display:none"></div>
</div>

<div id="budgetBar" class="budget-bar" style="display:none">
  <div class="budget-label">Formation Budget</div>
  <div class="budget-track">
    <div class="budget-fill ok" id="budgetFill"></div>
    <div class="budget-text" id="budgetText"></div>
  </div>
</div>

<div id="toolbarArea" class="toolbar" style="display:none">
  <button id="btnMerge" disabled>Merge Selected</button>
  <button id="btnAdd">+ Add Formation</button>
  <button id="btnSave" class="primary">Save JSON</button>
  <button id="btnUndo">Undo</button>
</div>

<div id="formationsArea" class="formations"></div>

<div id="spawnSection" style="display:none">
  <div class="section-title">Spawn Points (click monster to change type)</div>
  <div id="spawnCards"></div>
</div>

<div id="zoneSection" style="display:none">
  <div class="section-title">Zone Spawns (click monster to change type)</div>
  <div id="zoneCards"></div>
</div>

<div id="status"></div>

<script>
const SLOT_COLORS = [
  '#4fc3f7', '#81c784', '#ffb74d', '#e57373',
  '#ba68c8', '#4db6ac', '#fff176', '#f06292',
  '#90a4ae', '#aed581', '#64b5f6', '#ff8a65'
];

let areaData = null;
let formations = [];
let spawnPoints = [];
let zoneSpawns = [];
let undoStack = [];
let loadedFileName = '';
let serverMode = false;
let serverPath = '';

const $ = id => document.getElementById(id);

function slotColor(idx) { return SLOT_COLORS[idx % SLOT_COLORS.length]; }

function pushUndo() {
  undoStack.push(JSON.stringify({ formations, spawnPoints, zoneSpawns, monsterOverrides }));
  if (undoStack.length > 50) undoStack.shift();
}

function showStatus(msg, ok) {
  const el = $('status');
  el.textContent = msg;
  el.className = ok ? 'ok' : 'err';
  if (ok) setTimeout(() => { el.style.display = 'none'; }, 3000);
}

function computeBudget() {
  const totalSlots = formations.reduce((s, f) => s + f.slots.length, 0);
  const numFormations = formations.length;
  // Budget uses original table entry count (patcher pads with filler formations)
  const origCount = areaData.formation_count || numFormations;
  const budget = areaData.formation_area_bytes;
  const origTotalSlots = areaData.original_total_slots || Math.floor((budget - origCount * 4) / 32);
  const maxSlots = numFormations + origTotalSlots - origCount;
  const paddingCount = Math.max(0, origCount - numFormations);
  return { totalSlots, numFormations, origCount, budget, maxSlots, paddingCount };
}

function updateBudget() {
  const b = computeBudget();
  const pct = b.maxSlots > 0 ? Math.min(100, (b.totalSlots / b.maxSlots) * 100) : 100;
  $('budgetFill').style.width = pct + '%';
  let budgetStr = b.totalSlots + ' / ' + b.maxSlots + ' slots  (' + b.numFormations + ' formations';
  if (b.paddingCount > 0) {
    budgetStr += ' + ' + b.paddingCount + ' duplicate' + (b.paddingCount > 1 ? 's' : '');
  }
  budgetStr += ')';
  const freeSlots = b.maxSlots - b.totalSlots;
  if (freeSlots > 0) budgetStr += ' \u2014 ' + freeSlots + ' slots free';
  const isOver = b.totalSlots > b.maxSlots;
  const tooMany = b.numFormations > b.origCount;
  if (isOver) budgetStr += ' \u2014 OVER BUDGET';
  if (tooMany) budgetStr += ' \u2014 EXCEEDS TABLE CAPACITY (' + b.origCount + ' max)';
  $('budgetFill').className = 'budget-fill ' + (isOver || tooMany ? 'warn' : 'ok');
  $('budgetText').textContent = budgetStr;
}

function compositionFromSlots(slots, monsters) {
  const counts = {};
  const order = [];
  for (const s of slots) {
    if (!(s in counts)) order.push(s);
    counts[s] = (counts[s] || 0) + 1;
  }
  return order.map(s => ({
    count: counts[s],
    slot: s,
    monster: monsters[s] || '?slot' + s
  }));
}

function compositionFromRecords(records, monsters) {
  const counts = {};
  const order = [];
  for (const r of records) {
    const s = r.slot;
    if (!(s in counts)) order.push(s);
    counts[s] = (counts[s] || 0) + 1;
  }
  return order.map(s => ({
    count: counts[s],
    slot: s,
    monster: monsters[s] || '?slot' + s
  }));
}

function renderFormations() {
  const area = $('formationsArea');
  area.innerHTML = '';
  const monsters = areaData.monsters;

  if (formations.length === 0) {
    area.innerHTML = '<div class="empty">No formations. Click "+ Add Formation" to create one.</div>';
    updateBudget();
    updateMergeBtn();
    return;
  }

  formations.forEach((f, fidx) => {
    const card = document.createElement('div');
    card.className = 'formation-card' + (f._selected ? ' selected' : '');

    // Header
    const hdr = document.createElement('div');
    hdr.className = 'formation-card-header';

    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = !!f._selected;
    cb.title = 'Select for merge';
    cb.addEventListener('change', () => { f._selected = cb.checked; card.className = 'formation-card' + (f._selected ? ' selected' : ''); updateMergeBtn(); });

    const lbl = document.createElement('span');
    lbl.className = 'f-label';
    lbl.textContent = 'F' + String(fidx).padStart(2, '0');

    const tot = document.createElement('span');
    tot.className = 'f-total';
    tot.textContent = f.slots.length + ' slot' + (f.slots.length !== 1 ? 's' : '');

    const suf = document.createElement('span');
    suf.className = 'f-suffix';
    suf.textContent = 'suffix: ' + f.suffix;

    hdr.appendChild(cb);
    hdr.appendChild(lbl);
    hdr.appendChild(tot);
    hdr.appendChild(suf);
    card.appendChild(hdr);

    // Pills
    const pills = document.createElement('div');
    pills.className = 'pills';
    const comp = compositionFromSlots(f.slots, monsters);
    for (const c of comp) {
      const pill = document.createElement('span');
      pill.className = 'pill';
      pill.style.background = slotColor(c.slot);
      pill.textContent = c.count + 'x ' + c.monster;
      pills.appendChild(pill);
    }
    card.appendChild(pills);

    // Slot controls
    const controls = document.createElement('div');
    controls.className = 'slot-controls';
    for (let si = 0; si < monsters.length; si++) {
      const cnt = f.slots.filter(s => s === si).length;
      const ctrl = document.createElement('div');
      ctrl.className = 'slot-control';

      const nm = document.createElement('span');
      nm.className = 'name';
      nm.style.color = slotColor(si);
      nm.textContent = monsters[si];

      const minus = document.createElement('button');
      minus.textContent = '-';
      minus.disabled = cnt === 0;
      minus.addEventListener('click', () => { pushUndo(); removeSlot(fidx, si); });

      const cntSpan = document.createElement('span');
      cntSpan.className = 'count';
      cntSpan.textContent = cnt;

      const plus = document.createElement('button');
      plus.textContent = '+';
      plus.addEventListener('click', () => { pushUndo(); addSlot(fidx, si); });

      ctrl.appendChild(nm);
      ctrl.appendChild(minus);
      ctrl.appendChild(cntSpan);
      ctrl.appendChild(plus);
      controls.appendChild(ctrl);
    }
    card.appendChild(controls);

    // Actions
    const actions = document.createElement('div');
    actions.className = 'card-actions';

    const delBtn = document.createElement('button');
    delBtn.className = 'danger';
    delBtn.textContent = 'Delete';
    delBtn.addEventListener('click', () => { pushUndo(); formations.splice(fidx, 1); renderFormations(); });

    const dupBtn = document.createElement('button');
    dupBtn.textContent = 'Duplicate';
    dupBtn.addEventListener('click', () => { pushUndo(); formations.splice(fidx + 1, 0, JSON.parse(JSON.stringify(f))); formations[fidx + 1]._selected = false; renderFormations(); });

    const upBtn = document.createElement('button');
    upBtn.textContent = '\u2191';
    upBtn.title = 'Move up';
    upBtn.disabled = fidx === 0;
    upBtn.addEventListener('click', () => { pushUndo(); [formations[fidx-1], formations[fidx]] = [formations[fidx], formations[fidx-1]]; renderFormations(); });

    const dnBtn = document.createElement('button');
    dnBtn.textContent = '\u2193';
    dnBtn.title = 'Move down';
    dnBtn.disabled = fidx === formations.length - 1;
    dnBtn.addEventListener('click', () => { pushUndo(); [formations[fidx], formations[fidx+1]] = [formations[fidx+1], formations[fidx]]; renderFormations(); });

    actions.appendChild(upBtn);
    actions.appendChild(dnBtn);
    actions.appendChild(dupBtn);
    actions.appendChild(delBtn);
    card.appendChild(actions);

    area.appendChild(card);
  });

  updateBudget();
  updateMergeBtn();
}

function addSlot(fidx, slotIdx) {
  formations[fidx].slots.push(slotIdx);
  formations[fidx].slots.sort((a, b) => a - b);
  renderFormations();
}

function removeSlot(fidx, slotIdx) {
  const idx = formations[fidx].slots.indexOf(slotIdx);
  if (idx >= 0) {
    formations[fidx].slots.splice(idx, 1);
    if (formations[fidx].slots.length === 0) {
      formations.splice(fidx, 1);
    }
    renderFormations();
  }
}

function updateMergeBtn() {
  const sel = formations.filter(f => f._selected);
  $('btnMerge').disabled = sel.length < 2;
}

function mergeSelected() {
  const selIdx = [];
  formations.forEach((f, i) => { if (f._selected) selIdx.push(i); });
  if (selIdx.length < 2) return;

  pushUndo();

  const target = formations[selIdx[0]];
  for (let i = 1; i < selIdx.length; i++) {
    target.slots = target.slots.concat(formations[selIdx[i]].slots);
  }
  target.slots.sort((a, b) => a - b);
  target._selected = false;

  for (let i = selIdx.length - 1; i >= 1; i--) {
    formations.splice(selIdx[i], 1);
  }

  renderFormations();
  showStatus('Merged ' + selIdx.length + ' formations', true);
}

function addFormation() {
  pushUndo();
  formations.push({
    slots: [0],
    suffix: '00000000',
    _selected: false
  });
  renderFormations();
}

function undo() {
  if (undoStack.length === 0) return;
  const state = JSON.parse(undoStack.pop());
  formations = state.formations;
  spawnPoints = state.spawnPoints;
  zoneSpawns = state.zoneSpawns;
  monsterOverrides = state.monsterOverrides || [];
  renderFormations();
  renderOverrides();
  renderSpawnSection(spawnPoints, 'spawnSection', 'spawnCards');
  renderSpawnSection(zoneSpawns, 'zoneSection', 'zoneCards');
  showStatus('Undo', true);
}

// --- Spawn / Zone Spawn editing ---

function renderSpawnSection(groups, sectionId, containerId) {
  const section = $(sectionId);
  const container = $(containerId);
  container.innerHTML = '';

  if (!groups || groups.length === 0) {
    section.style.display = 'none';
    return;
  }
  section.style.display = 'block';

  const monsters = areaData.monsters;
  const numSlots = monsters.length;

  groups.forEach((group, gidx) => {
    const card = document.createElement('div');
    card.className = 'spawn-card';

    // Header with composition pills
    const hdr = document.createElement('div');
    hdr.className = 'spawn-card-header';

    const lbl = document.createElement('span');
    lbl.className = 'g-label';
    lbl.textContent = 'Group ' + gidx;

    const info = document.createElement('span');
    info.className = 'g-info';
    info.textContent = group.records.length + ' record' + (group.records.length !== 1 ? 's' : '');

    const suf = document.createElement('span');
    suf.className = 'g-suffix';
    suf.textContent = 'suffix: ' + (group.suffix || '00000000');

    hdr.appendChild(lbl);
    hdr.appendChild(info);
    hdr.appendChild(suf);
    card.appendChild(hdr);

    // Composition pills (rebuilt from records)
    const pills = document.createElement('div');
    pills.className = 'pills';
    const comp = compositionFromRecords(group.records, monsters);
    for (const c of comp) {
      const pill = document.createElement('span');
      pill.className = 'pill';
      pill.style.background = slotColor(c.slot);
      pill.textContent = c.count + 'x ' + c.monster;
      pills.appendChild(pill);
    }
    card.appendChild(pills);

    // Records
    const recsDiv = document.createElement('div');
    recsDiv.className = 'spawn-records';

    group.records.forEach((rec, ridx) => {
      const row = document.createElement('div');
      row.className = 'spawn-record';

      // Clickable slot pill - cycles through monsters
      const recPill = document.createElement('span');
      recPill.className = 'rec-pill';
      recPill.style.background = slotColor(rec.slot);
      recPill.textContent = monsters[rec.slot] || '?slot' + rec.slot;
      recPill.title = 'Click to change monster type (slot ' + rec.slot + ')';
      recPill.addEventListener('click', () => {
        pushUndo();
        rec.slot = (rec.slot + 1) % numSlots;
        // Re-render just this section
        renderSpawnSection(groups, sectionId, containerId);
      });
      recPill.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        pushUndo();
        rec.slot = (rec.slot - 1 + numSlots) % numSlots;
        renderSpawnSection(groups, sectionId, containerId);
      });

      const coords = document.createElement('span');
      coords.className = 'rec-coords';
      coords.textContent = '(' + rec.x + ', ' + rec.y + ', ' + rec.z + ')';

      const meta = document.createElement('span');
      meta.className = 'rec-meta';
      meta.textContent = 'b0:' + rec.byte0 + ' id:' + rec.area_id;

      row.appendChild(recPill);
      row.appendChild(coords);
      row.appendChild(meta);
      recsDiv.appendChild(row);
    });

    card.appendChild(recsDiv);
    container.appendChild(card);
  });
}

// --- Monster overrides (Elite system) ---

let monsterOverrides = []; // per-slot: null or {elite: true, type07_vram: "0x..."}

function initOverrides() {
  const monsters = areaData.monsters || [];
  const existing = areaData.monster_overrides || [];
  monsterOverrides = [];
  for (let i = 0; i < monsters.length; i++) {
    monsterOverrides.push(existing[i] || null);
  }
}

function getSlotVram(si) {
  // Direct: type07_entries from this area's binary
  const entries = areaData.type07_entries || [];
  if (si < entries.length && entries[si]) return entries[si].vram_offset || '';
  // Fallback: monster_vram_ref from monster_db (another area on same floor)
  const ref = areaData.monster_vram_ref || {};
  const monsters = areaData.monsters || [];
  if (si < monsters.length && ref[monsters[si]]) return ref[monsters[si]];
  return '';
}

function renderOverrides() {
  const section = $('overridesSection');
  const body = $('overridesBody');
  if (!areaData || !areaData.monsters) {
    section.style.display = 'none';
    return;
  }
  section.style.display = 'block';
  body.innerHTML = '';

  const monsters = areaData.monsters;

  for (let si = 0; si < monsters.length; si++) {
    const ov = monsterOverrides[si];
    const isElite = ov && ov.elite;

    const card = document.createElement('div');
    card.className = 'override-card' + (isElite ? ' active' : '');

    const hdr = document.createElement('div');
    hdr.className = 'override-header';

    const chip = document.createElement('span');
    chip.className = 'slot-chip';
    chip.style.background = slotColor(si);
    chip.textContent = si;

    const name = document.createElement('span');
    name.className = 'slot-name';
    name.textContent = monsters[si];

    // Elite checkbox
    const eliteLbl = document.createElement('label');
    eliteLbl.style.cssText = 'margin-left:auto;display:flex;align-items:center;gap:5px;cursor:pointer;font-size:0.85em;color:#e94560;font-weight:700;';
    const eliteCb = document.createElement('input');
    eliteCb.type = 'checkbox';
    eliteCb.checked = isElite;
    eliteCb.style.accentColor = '#e94560';
    eliteCb.addEventListener('change', () => {
      if (eliteCb.checked) {
        monsterOverrides[si] = { elite: true, type07_vram: getSlotVram(si) };
      } else {
        monsterOverrides[si] = null;
      }
      renderOverrides();
    });
    eliteLbl.appendChild(eliteCb);
    eliteLbl.appendChild(document.createTextNode('ELITE'));

    hdr.appendChild(chip);
    hdr.appendChild(name);
    hdr.appendChild(eliteLbl);
    card.appendChild(hdr);

    // Elite details row
    if (isElite) {
      const details = document.createElement('div');
      details.className = 'override-body';

      // Stats summary
      const statsInfo = document.createElement('div');
      statsInfo.style.cssText = 'font-size:0.8em;color:#53a8b6;';
      statsInfo.textContent = 'E-name, HP x2, Magic x2, Armor x2, Dmg x1.5, armor_type=boss';
      details.appendChild(statsInfo);

      // VRAM offset
      const vramRow = document.createElement('div');
      vramRow.className = 'override-row';
      const vramLbl = document.createElement('label');
      vramLbl.textContent = 'VRAM offset';
      const vramInp = document.createElement('input');
      vramInp.type = 'text';
      vramInp.placeholder = getSlotVram(si) || '0x0000';
      vramInp.value = ov.type07_vram || '';
      vramInp.addEventListener('input', () => {
        ov.type07_vram = vramInp.value || undefined;
      });
      vramRow.appendChild(vramLbl);
      vramRow.appendChild(vramInp);
      // Show original VRAM hint (from this area or reference from same floor)
      const t07 = (areaData.type07_entries || [])[si];
      const directVram = t07 ? (t07.vram_offset || '') : '';
      const refVram = (areaData.monster_vram_ref || {})[monsters[si]] || '';
      if (directVram) {
        const origSpan = document.createElement('span');
        origSpan.style.cssText = 'font-size:0.8em;color:#606070;';
        origSpan.textContent = '(original: ' + directVram + ')';
        vramRow.appendChild(origSpan);
      } else if (refVram) {
        const origSpan = document.createElement('span');
        origSpan.style.cssText = 'font-size:0.8em;color:#505060;font-style:italic;';
        origSpan.textContent = '(ref: ' + refVram + ')';
        vramRow.appendChild(origSpan);
      }
      details.appendChild(vramRow);

      card.appendChild(details);
    }

    body.appendChild(card);
  }
}

// Toggle overrides section
$('overridesToggle').addEventListener('click', () => {
  const body = $('overridesBody');
  const arrow = $('overridesArrow');
  if (body.style.display === 'none') {
    body.style.display = 'block';
    arrow.innerHTML = '&#9660;';
  } else {
    body.style.display = 'none';
    arrow.innerHTML = '&#9654;';
  }
});

// --- Build output ---

function buildOutputJSON() {
  const out = JSON.parse(JSON.stringify(areaData));
  const monsters = out.monsters;

  // Monster overrides (Elite flags)
  const hasAnyOverride = monsterOverrides.some(o => o !== null && o.elite);
  if (hasAnyOverride) {
    out.monster_overrides = monsterOverrides.map(o => {
      if (!o || !o.elite) return null;
      const clean = { elite: true };
      if (o.type07_vram) clean.type07_vram = o.type07_vram;
      return clean;
    });
  } else {
    delete out.monster_overrides;
  }

  // Rebuild formations
  out.formations = formations.map((f) => {
    const slots = f.slots.slice();
    const comp = compositionFromSlots(slots, monsters);
    const obj = {
      total: slots.length,
      composition: comp,
      slots: slots,
      suffix: f.suffix || '00000000'
    };
    if (f.offset) obj.offset = f.offset;
    return obj;
  });

  // Preserve formation_count from loaded data (= original table entry count).
  // The patcher uses this to know how many FM entries the offset table has.
  // Do NOT overwrite with formations.length (which may be fewer after merging).
  if (!areaData.formation_count) {
    out.formation_count = out.formations.length;
  }
  // Preserve original_total_slots from the loaded data (for patcher delta messages).
  if (!areaData.original_total_slots) {
    out.original_total_slots = formations.reduce((s, f) => s + f.slots.length, 0);
  }

  // Rebuild spawn points from edited records
  if (spawnPoints.length > 0) {
    out.spawn_points = spawnPoints.map(group => {
      const records = group.records.map(r => Object.assign({}, r));
      const comp = compositionFromRecords(records, monsters);
      return {
        total: records.length,
        composition: comp,
        records: records,
        suffix: group.suffix || '00000000',
        offset: group.offset || undefined
      };
    });
    out.spawn_point_count = out.spawn_points.length;
    out.original_total_spawn_slots = spawnPoints.reduce((s, g) => s + g.records.length, 0);
  }

  // Rebuild zone spawns from edited records
  if (zoneSpawns.length > 0) {
    out.zone_spawns = zoneSpawns.map(group => {
      const records = group.records.map(r => Object.assign({}, r));
      const comp = compositionFromRecords(records, monsters);
      return {
        total: records.length,
        composition: comp,
        records: records,
        suffix: group.suffix || '00000000',
        offset: group.offset || undefined
      };
    });
    out.zone_spawn_count = out.zone_spawns.length;
    out.original_total_zone_spawn_slots = zoneSpawns.reduce((s, g) => s + g.records.length, 0);
  }

  return out;
}

function saveJSON() {
  const b = computeBudget();
  if (b.used > b.budget) {
    showStatus('Cannot save: over budget by ' + (b.used - b.budget) + ' bytes!', false);
    return;
  }

  for (let i = 0; i < formations.length; i++) {
    if (formations[i].slots.length === 0) {
      showStatus('Cannot save: formation F' + String(i).padStart(2, '0') + ' is empty', false);
      return;
    }
  }

  const out = buildOutputJSON();

  if (serverMode && serverPath) {
    // Server mode: POST to save endpoint
    $('btnSave').disabled = true;
    fetch('/api/save/' + serverPath, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(out, null, 2)
    })
    .then(r => r.json().then(data => ({ ok: r.ok, data })))
    .then(({ ok, data }) => {
      $('btnSave').disabled = false;
      if (ok) {
        showStatus('Saved ' + serverPath, true);
      } else {
        showStatus('Save failed: ' + (data.error || 'unknown error'), false);
      }
    })
    .catch(err => {
      $('btnSave').disabled = false;
      showStatus('Save failed: ' + err.message, false);
    });
  } else {
    // Local mode: download file
    const json = JSON.stringify(out, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = loadedFileName || 'area.json';
    a.click();
    URL.revokeObjectURL(url);
    showStatus('Saved ' + a.download, true);
  }
}

// --- Load ---

function loadArea(data, fileName) {
  areaData = data;
  loadedFileName = fileName;

  $('areaInfo').style.display = 'block';
  $('areaTitle').textContent = (data.level_name || '?') + ' - ' + (data.name || '?');
  $('areaSubtitle').textContent = 'Area ID: ' + (data.area_id || '?') + '  |  Budget: ' + data.formation_area_bytes + ' bytes';

  // Palette
  const pal = $('palette');
  pal.innerHTML = '';
  (data.monsters || []).forEach((m, i) => {
    const chip = document.createElement('span');
    chip.className = 'palette-chip';
    chip.style.background = slotColor(i);
    chip.textContent = 'Slot ' + i + ': ' + m;
    pal.appendChild(chip);
  });

  // Load formations
  formations = (data.formations || []).map(f => ({
    slots: (f.slots || []).slice(),
    suffix: f.suffix || '00000000',
    offset: f.offset || null,
    _selected: false
  }));

  // Load spawn points (deep copy records)
  spawnPoints = (data.spawn_points || []).map(group => ({
    records: (group.records || []).map(r => Object.assign({}, r)),
    suffix: group.suffix || '00000000',
    offset: group.offset || null
  }));

  // Load zone spawns (deep copy records)
  zoneSpawns = (data.zone_spawns || []).map(group => ({
    records: (group.records || []).map(r => Object.assign({}, r)),
    suffix: group.suffix || '00000000',
    offset: group.offset || null
  }));

  undoStack = [];

  // Init monster overrides
  initOverrides();

  $('budgetBar').style.display = 'block';
  $('toolbarArea').style.display = 'flex';

  renderFormations();
  renderOverrides();
  renderSpawnSection(spawnPoints, 'spawnSection', 'spawnCards');
  renderSpawnSection(zoneSpawns, 'zoneSection', 'zoneCards');
}

// Event listeners
$('fileInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => {
    try {
      const data = JSON.parse(ev.target.result);
      if (!data.formations || !data.monsters) {
        showStatus('Invalid area JSON: missing "formations" or "monsters"', false);
        return;
      }
      loadArea(data, file.name);
      showStatus('Loaded ' + file.name, true);
    } catch (err) {
      showStatus('Parse error: ' + err.message, false);
    }
  };
  reader.readAsText(file);
});

$('btnMerge').addEventListener('click', mergeSelected);
$('btnAdd').addEventListener('click', addFormation);
$('btnSave').addEventListener('click', saveJSON);
$('btnUndo').addEventListener('click', undo);

// Drag & drop support
document.body.addEventListener('dragover', e => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
document.body.addEventListener('drop', e => {
  e.preventDefault();
  const file = e.dataTransfer.files[0];
  if (file && file.name.endsWith('.json')) {
    const reader = new FileReader();
    reader.onload = ev => {
      try {
        const data = JSON.parse(ev.target.result);
        if (!data.formations || !data.monsters) {
          showStatus('Invalid area JSON', false);
          return;
        }
        loadArea(data, file.name);
        showStatus('Loaded ' + file.name, true);
      } catch (err) {
        showStatus('Parse error: ' + err.message, false);
      }
    };
    reader.readAsText(file);
  }
});

// --- Server mode detection ---
let allFiles = [];

function prettify(name) {
  return name.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
}

function loadSelectedArea(path) {
  serverPath = path;
  fetch('/api/load/' + path)
    .then(r => { if (!r.ok) throw new Error('Load failed'); return r.json(); })
    .then(data => {
      if (!data.formations || !data.monsters) {
        showStatus('Invalid area JSON: missing "formations" or "monsters"', false);
        return;
      }
      loadArea(data, path.split('/').pop());
      showStatus('Loaded ' + path, true);
    })
    .catch(err => showStatus('Load error: ' + err.message, false));
}

fetch('/api/files')
  .then(r => { if (!r.ok) throw new Error('not served'); return r.json(); })
  .then(files => {
    serverMode = true;
    allFiles = files;
    $('headerLocal').style.display = 'none';
    $('headerServer').style.display = 'flex';

    // Build level list from unique directory prefixes
    const levels = [];
    const seen = {};
    for (const f of files) {
      const level = f.path.split('/')[0];
      if (!seen[level]) {
        seen[level] = true;
        levels.push(level);
      }
    }

    const levelSel = $('levelSelect');
    const areaSel = $('areaSelect');
    for (const lv of levels) {
      const opt = document.createElement('option');
      opt.value = lv;
      opt.textContent = prettify(lv);
      levelSel.appendChild(opt);
    }

    levelSel.addEventListener('change', () => {
      const lv = levelSel.value;
      areaSel.innerHTML = '<option value="">-- select area --</option>';
      areaSel.disabled = !lv;
      if (!lv) return;
      const matching = allFiles.filter(f => f.path.split('/')[0] === lv);
      for (const f of matching) {
        const opt = document.createElement('option');
        opt.value = f.path;
        const areaName = f.path.split('/').slice(1).join('/').replace('.json', '');
        opt.textContent = prettify(areaName);
        areaSel.appendChild(opt);
      }
      // Auto-load if only one area
      if (matching.length === 1) {
        areaSel.value = matching[0].path;
        loadSelectedArea(matching[0].path);
      }
    });

    areaSel.addEventListener('change', () => {
      const path = areaSel.value;
      if (!path) return;
      loadSelectedArea(path);
    });
  })
  .catch(() => {
    // Not running from server - keep local file mode
  });
</script>
</body>
</html>
